// js/index.js
import { initRecording, stopRecordingOnARSessionEnd } from './recording.js';

/**
 * Fetch mit Timeout und AbortError-Erkennung.
 * @param {string} url
 * @param {RequestInit & { timeoutMs?: number }} options
 * @returns {Promise<Response>}
 */
async function fetchWithTimeout(url, options = {}) {
  const { timeoutMs = 15000 } = options;
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { ...options, signal: controller.signal });
    return res;
  } catch (err) {
    if (err.name === 'AbortError') {
      throw new Error(`Timeout (${timeoutMs} ms) beim Laden: ${url}`);
    }
    throw err;
  } finally {
    clearTimeout(id);
  }
}

/**
 * L√§dt die Szene-Konfiguration.
 * @param {string} sceneId
 * @param {string} workerBase
 */
async function loadSceneConfig(sceneId, workerBase) {
  const sceneConfigUrl = `${workerBase}/scenes/${sceneId}/scene.json`;
  const res = await fetchWithTimeout(sceneConfigUrl, { timeoutMs: 15000 });
  if (!res.ok) {
    throw new Error(`Scene-Konfiguration konnte nicht geladen werden (${res.status})`);
  }
  return res.json();
}

/**
 * Erzeugt einen slug aus einem Label f√ºr den Slot-Namen.
 * @param {string} label
 */
function slugify(label) {
  return (label || 'hotspot')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g,'-')
    .replace(/^-+|-+$/g,'');
}

/**
 * Erstellt Hotspots aus clickableNodes (inkl. Position).
 * @param {HTMLElement} mvEl
 * @param {Array<{label:string,url:string,position?:{x:number,y:number,z:number}}>} clickableNodes
 */
function createHotspotsFromClickableNodes(mvEl, clickableNodes) {
  if (!Array.isArray(clickableNodes) || clickableNodes.length === 0) return;

  clickableNodes.forEach((node, idx) => {
    if (!node.url) return;

    if (!node.position ||
        typeof node.position.x !== 'number' ||
        typeof node.position.y !== 'number' ||
        typeof node.position.z !== 'number') {
      console.warn('Hotspot ohne g√ºltige Position √ºbersprungen:', node);
      return;
    }

    const slotName = `hotspot-${slugify(node.label || ('link'+idx))}`;

    const hotspot = document.createElement('button');
    hotspot.setAttribute('slot', slotName);
    hotspot.className = 'Hotspot';
    hotspot.textContent = node.label || `Link ${idx+1}`;

    hotspot.setAttribute(
      'data-position',
      `${node.position.x} ${node.position.y} ${node.position.z}`
    );
    hotspot.setAttribute('data-normal', '0 1 0');

    hotspot.addEventListener('click', (e) => {
      e.stopPropagation();
      window.open(node.url, '_blank');
    });

    mvEl.appendChild(hotspot);
  });
}

/* -------- Globale Zust√§nde -------- */
let cfg = null;
let arAudio = null;
let isAudioMuted = false;
let arSessionActive = false;

/* -------- DOM Referenzen -------- */
const loadingStatus   = document.getElementById('loading-status');
const container       = document.getElementById('ar-container');
const poster          = document.getElementById('poster');
const posterTitle     = document.getElementById('posterTitle');
const posterSubtitle  = document.getElementById('posterSubtitle');
const posterText      = document.getElementById('posterText');
const posterMedia     = document.getElementById('poster-media');
const posterImageEl   = document.getElementById('posterImageEl');
const startArButton   = document.getElementById('startAr');
const mvEl            = document.getElementById('ar-scene-element');
const arUI            = document.getElementById('ar-ui');
const btnMute         = document.getElementById('btn-mute');
const errEl           = document.getElementById('err');

/* -------- Hilfsfunktionen UI/Logik -------- */
function displayError(message) {
  console.error('VIEWER ERROR:', message);
  if (errEl) {
    errEl.textContent = 'FEHLER: ' + message;
    errEl.style.display = 'block';
  }
  if (loadingStatus) loadingStatus.textContent = 'Fehler: ' + message;
}

function updateMuteButtonUI() {
  if (!btnMute) return;
  btnMute.textContent = isAudioMuted ? 'üîá' : 'üîä';
}

function initAudio(audioCfg, sceneId, workerBase) {
  if (!btnMute) return;
  if (!audioCfg || !audioCfg.url) {
    btnMute.style.display = 'none';
    return;
  }
  const audioUrl = `${workerBase}/scenes/${sceneId}/${audioCfg.url}`;
  arAudio = new Audio(audioUrl);
  arAudio.loop = !!audioCfg.loop;
  arAudio.volume = audioCfg.volume !== undefined ? audioCfg.volume : 0.8;

  btnMute.style.display = 'flex';
  updateMuteButtonUI();
  btnMute.onclick = () => {
    isAudioMuted = !isAudioMuted;
    arAudio.muted = isAudioMuted;
    updateMuteButtonUI();
  };
}

function toggleAudio(play) {
  if (!arAudio) return;
  if (play) {
    if (!isAudioMuted) {
      const delay = cfg?.audio?.delaySeconds || 0;
      if (delay > 0) {
        setTimeout(
          () => arAudio.play().catch(e => console.warn('Audio play failed:', e)),
          delay * 1000
        );
      } else {
        arAudio.play().catch(e => console.warn('Audio play failed:', e));
      }
    }
  } else {
    arAudio.pause();
    arAudio.currentTime = 0;
  }
}

function applyYOffset(yOffset) {
  if (typeof yOffset !== 'number') return;
  const px = (-yOffset * 100).toFixed(0) + 'px';
  document.documentElement.style.setProperty('--model-vertical-offset', px);
  console.log(`Y-Offset angewandt (nur Nicht-AR 3D-Ansicht): ${px}`);
}

/* ---------- Szene laden & konfigurieren ---------- */
async function initializeViewer(sceneId, workerBase) {
  if (!mvEl || mvEl.tagName !== 'MODEL-VIEWER') {
    displayError('model-viewer Element fehlt oder falsch.');
    return;
  }

  let config;
  try {
    config = await loadSceneConfig(sceneId, workerBase);
  } catch (e) {
    displayError(e.message);
    return;
  }
  cfg = config;

  if (!cfg.model || !cfg.model.url) {
    displayError('Kein 3D-Modell in Konfiguration.');
    return;
  }

  const modelUrl = `${workerBase}/scenes/${sceneId}/${cfg.model.url}`;
  mvEl.setAttribute('src', modelUrl);
  mvEl.setAttribute('alt', cfg.meta?.title || '3D Modell');
  mvEl.setAttribute('shadow-intensity', '1');
  mvEl.setAttribute('camera-controls', '');
  mvEl.setAttribute('auto-rotate', '');
  mvEl.setAttribute('ar', '');
  mvEl.setAttribute('ar-modes', 'webxr scene-viewer quick-look');
  mvEl.setAttribute('interaction-prompt', 'none');
  mvEl.setAttribute('auto-rotate-delay', '1000');
  mvEl.setAttribute('disable-tap', '');

  if (cfg.environmentImage) {
    mvEl.setAttribute('environment-image', cfg.environmentImage);
  }
  if (typeof cfg.exposure === 'number') {
    mvEl.setAttribute('exposure', String(cfg.exposure));
  }

  // Hotspots aus clickableNodes inklusive Positionen
  createHotspotsFromClickableNodes(mvEl, cfg.clickableNodes);

  // Audio init
  initAudio(cfg.audio, sceneId, workerBase);

  // Y-Offset nur f√ºr 3D-Modus
  if (typeof cfg.model.yOffset === 'number') {
    applyYOffset(cfg.model.yOffset);
  }

  // Poster-Texte & Bild aus meta
  const meta = cfg.meta || {};
  const title    = meta.title    || 'AR Erlebnis';
  const subtitle = meta.subtitle || '';
  const body     = meta.body     || 'Tippe auf START AR, um das Modell in deiner Umgebung zu sehen.';

  if (posterTitle)    posterTitle.textContent = title;
  if (posterSubtitle) {
    if (subtitle.trim()) {
      posterSubtitle.textContent = subtitle;
      posterSubtitle.classList.remove('hidden');
    } else {
      posterSubtitle.textContent = '';
      posterSubtitle.classList.add('hidden');
    }
  }
  if (posterText)     posterText.textContent = body;

  if (meta.posterImage && posterImageEl && posterMedia) {
    const posterUrl = `${workerBase}/scenes/${sceneId}/${meta.posterImage}`;
    posterImageEl.src = posterUrl;
    posterMedia.classList.remove('hidden');
  } else if (posterMedia) {
    posterMedia.classList.add('hidden');
  }

  // Optional: Dokumenttitel anpassen
  try {
    if (title) document.title = `ARea Viewer ‚Äì ${title}`;
  } catch (_) {}

  // Anzeige wechseln
  if (loadingStatus) loadingStatus.style.display = 'none';
  if (container) container.style.display = 'block';

  mvEl.addEventListener('load', () => {
    console.log('Modell geladen.');
    mvEl.removeAttribute('auto-rotate');
  });

  mvEl.addEventListener('error', (e) => {
    console.error('model-viewer Fehler:', e);
    displayError('Fehler beim Laden des Modells.');
    if (container) container.style.display = 'none';
  });

  // AR Status Handling
  mvEl.addEventListener('ar-status', async (event) => {
    const status = event.detail.status;
    if (status === 'session-started') {
      arSessionActive = true;
      if (poster) poster.style.display = 'none';
      if (arUI)   arUI.style.display = 'block';
      toggleAudio(true);
      mvEl.querySelectorAll('.Hotspot').forEach(h => h.classList.add('in-ar'));
    } else if (status === 'session-ended') {
      arSessionActive = false;
      if (arUI)   arUI.style.display = 'none';
      toggleAudio(false);
      if (poster) poster.style.display = 'flex';
      mvEl.querySelectorAll('.Hotspot').forEach(h => h.classList.remove('in-ar'));
      // Aufnahme sauber beenden (Fallback, falls noch aktiv)
      await stopRecordingOnARSessionEnd();
    } else if (status === 'failed') {
      arSessionActive = false;
      if (startArButton) startArButton.disabled = false;
      displayError('AR konnte nicht gestartet werden.');
    }
  });

  // Fallback-Klick auf Modell (ohne Hotspots)
  mvEl.addEventListener('click', () => {
    if (!cfg.clickableNodes || cfg.clickableNodes.length === 0) return;
    const anyHotspot = mvEl.querySelector('.Hotspot');
    if (anyHotspot) return;
    const node = cfg.clickableNodes[0];
    if (node?.url) {
      if (arSessionActive) {
        mvEl.dismissAR?.();
        setTimeout(() => window.open(node.url, '_blank'), 600);
      } else {
        window.open(node.url, '_blank');
      }
    }
  });
}

/* ---------- Bootstrap ---------- */
document.addEventListener('DOMContentLoaded', () => {
  const params = new URLSearchParams(window.location.search);
  const sceneId   = params.get('scene');
  const workerBase = params.get('base');

  if (!sceneId || !workerBase) {
    displayError('Fehlende URL-Parameter (scene/base).');
    return;
  }

  // START AR Button
  if (startArButton) {
    startArButton.onclick = () => {
      startArButton.disabled = true;
      mvEl.activateAR();
      // Fallback: Falls AR nicht startet
      setTimeout(() => {
        if (!arSessionActive) startArButton.disabled = false;
      }, 5000);
    };
  }

  // Aufnahme / Galerie-UI initialisieren
  initRecording();

  // Initial Start
  initializeViewer(sceneId, workerBase);
});
